import bs4
from bs4 import BeautifulSoup as bs
import datetime as dt
import re

# dict to map month strings to the digit representation of the month
month_dict = {"Jan":"01", "Januar":"01", "Jänner":"01", "Feb":"02", "Febr": "02", "Februar":"02", "Hörnung":"02", "März":"03",
"April": "04", "May":"05", "Jun": "06", "Juni": "06", "Junius": "06", "Jul":"07", "Julius":"07", "Aug":"08", "August":"08",
"Sept":"09", "September":"09", "Oct":"10", "October":"10", "Nov":"11", "November":"11", "Dec":"12", "December":"12"}

# regex pattern to match months (Bronners early 19th century German)
month_pattern = """(Jan(uar)?|Jänner|Feb(ruar)?|Hörnung|Mär(z)?|Apr(il)?|May|Jun(i|ius)?|Jul(ius)?|
Aug(ust)?|Sept(ember)?|Oct(ober)?|Nov(ember)?|Dec(ember)?)"""

def refine_dates(bs_soup_object):
    """This function takes an bs.soup object of a TEI annotated XML
     and refines the automated annotations generated by 'heideltime'"""
    for date in bs_soup_object.find_all('date'):
        if date.parent.name == "date":
# the inner date tag (inside a date tag) is unwrapped,
# this usually happens if heideltime identifies a shorter component of an allready annotated date
            date.unwrap()
        if date.find_previous_sibling() == None: # prevents None has not attribute name errors
            pass
        elif date.find_previous_sibling().name == "date":
            if len(date['when']) == len(date.find_previous_sibling()['when']): 
                # probably there are two dates following each other, if they are 12 days
                # appart they are gregorian and julian for the same date and will be annotated regarding 
                try:
                    day1 = dt.datetime(int(date.find_previous_sibling()['when'][:4]),
                        int(date.find_previous_sibling()['when'][5:7]),
                        int(date.find_previous_sibling()['when'][8:]))
                    day2 = dt.datetime(int(date['when'][:4]),int(date['when'][5:7]),
                        int(date['when'][8:]))
                    if (day1-day2).days == 12:
                        date.find_previous_sibling()['calendar'] = '#gregorian'
                    elif (day2-day1).days == 12:
                        date['calendar'] = '#gregorian'
                except Exception as e:
                    print(e)
            elif str(date.previous_sibling) == " ": 
                # two following date tags annotate components of the same date and will be merged
                date.find_previous_sibling().string = date.find_previous_sibling().string + " " + date.string
                date.previous_sibling.replace_with("")
                date.decompose()
        if type(date.previous_sibling) == bs4.element.NavigableString:
            # the following code searches for patterns in front of a date tag, that resembles dates,
            # if found they are included in the tag and the "when" attribute is updated using the given information
            if re.search('\d{1,2}(\.|(te|ten))', str(date.previous_sibling)) and date.string:
                try:
                    match = re.search('(?=[\D\n])\d{1,2}(?=[\D\n])', str(date.previous_sibling))
                    start = match.start()
                    day = date.previous_sibling[match.start():match.end()]
                    month_match = re.search(month_pattern, str(date.previous_sibling))
                    month = None
                    if month_match:
                        month = date.previous_sibling[month_match.start():month_match.end()]
                    date.string.replace_with(date.previous_sibling[start:]+date.string)
                    date.previous_sibling.replace_with(date.previous_sibling[:start])
                    if len(date['when']) == 10:
                        # the date has allready the structure YYYY-MM-DD
                        pass
                    elif len(date['when']) == 7:
                        # the date has the sturcture YYYY-MM, if possible days will be appended
                        if len(day) == 1:
                            day = "0"+day
                        date['when'] = f"{date['when']}-{day}"
                    elif len(date['when']) == 4:
                        # the date consist only of the year YYYY, if possible days and month will be appended
                        if not month: 
                            pass
                        else:
                            if len(day) == 1:
                                day = "0"+day
                            date['when'] = f"{date['when']}-{month_dict[month]}-{day}"
                except Exception as e:
                    print(e)
            # this loop searches for dates given in both gregorian and julian calender and annotates both forms
            if re.search('\d{1,2}\D+\d{1,2}\D+', str(date.string)):
                matcher = re.findall('\d{1,2}\.* [A-Z][a-z]+\.', str(date.string))
                if len(matcher) == 1: # same month for both days
                    try:
                        month = month_dict[re.findall('[A-Z][a-z]+(?=\.)', date.string)[0]]
                        days  = re.findall('\d{1,2}(?=\D)', str(date.string))
                        first_day = re.search('\d{1,2}\.*', str(date.string))
                        # the pattern could match digits like 34, wich do not represent dates and would therefore 
                        # break the programm
                        day1 = dt.datetime(int(date['when'][:4]), int(month), int(days[0]))
                        day2 = dt.datetime(int(date['when'][:4]), int(month), int(days[1]))
                        if (day1-day2).days == 12:
                            greg_date = bs_soup_object.new_tag('date', calendar='#gregorian',
                                when=day1.strftime('%Y-%m-%d'))
                            greg_date.string = date.string[:first_day.end()]
                            date.string = date.string[first_day.end():]
                            date.insert_before(greg_date)
                        elif (day1-day2).days == -12:
                            greg_date = bs_soup_object.new_tag('date', calendar='#gregorian',
                                when=day2.strftime('%Y-%m-%d'))
                            greg_date.string = date.string[first_day.end():]
                            date.string = date.string[:first_day.end()]
                            date.insert_after(greg_date)
                    except Exception as e:
                        print(e)
                elif len(matcher) == 2: # different month for each day
                    days = re.findall('\d{1,2}(?=\D)', date.string)
                    months = re.findall('[A-Z][a-z]+(?=\.)', date.string)
                    first_date = re.search('\d{1,2}\.* [A-Z][a-z]+\.*', str(date.string))
                    day1 = dt.datetime(int(date['when'][:4]),
                        int(month_dict[months[0]]), int(days[0]))
                    day2 = dt.datetime(int(date['when'][:4]),
                        int(month_dict[months[1]]), int(days[1]))
                    if (day1-day2).days == 12:
                        greg_date = bs_soup_object.new_tag('date', calendar='#gregorian',
                            when=day1.strftime('%Y-%m-%d'))
                        greg_date.string = date.string[:first_date.end()]
                        date.string = date.string[first_date.end():]
                        date.insert_before(greg_date)
                    elif (day1-day2).days == -12:
                        greg_date = bs_soup_object.new_tag('date', calendar='#gregorian', 
                            when=day2.strftime('%Y-%m-%d'))
                        greg_date.string = date.string[first_date.end():]
                        date.string = date.string[:first_date.end()]
                        date.insert_after(greg_date)
            
    return bs_soup_object

def refine_time(bs_soup_object):
    """This function takes an bs.soup object of a TEI annotated XML and refines the automated
     annotations generated by 'heideltime'"""
    for time in bs_soup_object.find_all('time'):
        if "when" in time.attrs:
            if re.search('(Nacht)s*', time.previous_sibling):
                # times in time are transfered to the 24h format (instead of 12h format used by Bronner)
                if int(time['when'][:2]) == 12:
                    time['when'] = "00:00:00"
                elif int(time['when'][:2]) > 6:
                    new_time = int(time['when'][:2]) + 12
                    time['when'] = str(new_time) + ":00:00"
            if re.search('(halb|[123]/[24])', time.previous_sibling):
                # previous specifications like half past, quater to etc. are included in the time annotation
                match = re.search('(halb|[123]/[24])', time.previous_sibling)
                start = match.start()
                if re.search('(halb|1/2)', time.previous_sibling):
                    new_time = int(time['when'][:2]) - 1
                    if new_time < 10:
                        time['when'] = "0" + str(new_time) + ":30:00"
                    else:
                        time['when'] = str(new_time) + ":30:00"
                    if time.string == None: 
                    # if there is a selfclosing tag (<lb/>) included in the tag, the string method is not working
                        pass
                    else:
                        time.string.replace_with(time.previous_sibling[start:]+time.string)
                        time.previous_sibling.replace_with(time.previous_sibling[:start])
                if re.search('3/4', time.previous_sibling):
                    new_time = int(time['when'][:2]) - 1
                    if new_time < 10:
                        time['when'] = "0" + str(new_time) + ":45:00"
                    else:
                        time['when'] = str(new_time) + ":45:00"
                    if time.string == None: 
                        pass
                    else:
                        time.string.replace_with(time.previous_sibling[start:]+time.string)
                        time.previous_sibling.replace_with(time.previous_sibling[:start])
                if re.search('1/4', time.previous_sibling):
                    time['when'] = time['when'][:3] + "15:00"
                    if time.string == None: 
                        pass
                    else:
                        time.string.replace_with(time.previous_sibling[start:]+time.string)
                        time.previous_sibling.replace_with(time.previous_sibling[:start])
    
    return bs_soup_object
